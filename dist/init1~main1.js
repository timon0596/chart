(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["init1~main1"],{

/***/ "./src/components/chartname/chartname.js":
/*!***********************************************!*\
  !*** ./src/components/chartname/chartname.js ***!
  \***********************************************/
/*! exports provided: Chartname */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chartname\", function() { return Chartname; });\nclass Chartname {\n  constructor({\n    color,\n    name\n  }) {\n    this.container = $('<div>', {\n      class: 'chartname'\n    });\n    this.chartname = $('<div>', {\n      class: 'chartname__text'\n    });\n    this.chartnameColor = $('<div>', {\n      class: 'chartname__color'\n    });\n    this.color = color;\n    this.name = name;\n    this.init();\n  }\n\n  init() {\n    this.container.append(this.chartnameColor).append(this.chartname);\n    this.chartname.text(this.name);\n    this.chartnameColor.css('background', this.color);\n  }\n\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./src/components/chartname/chartname.js?");

/***/ }),

/***/ "./src/components/slider/slider.js":
/*!*****************************************!*\
  !*** ./src/components/slider/slider.js ***!
  \*****************************************/
/*! exports provided: Slider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Slider\", function() { return Slider; });\nclass Slider {\n  constructor(isSectionSlider) {\n    this.isSectionSlider = isSectionSlider;\n    this.chunkDistance;\n    this.pos = [0, 1];\n    this.mousedown = false;\n    this.currentHandle = 0;\n    this.el = $('<div>', {\n      class: 'slider'\n    });\n    this.handles = new Array(2).fill(0).map(() => $('<div>', {\n      class: 'handle'\n    }));\n    this.chunkHandle = $('<div>', {\n      class: 'chunkHandle'\n    });\n\n    if (this.isSectionSlider) {\n      this.el.append(this.chunkHandle);\n      this.chunkHandle.mousedown(() => {\n        this.mousedown = true;\n      });\n    } else {\n      this.handles.forEach((el, i) => {\n        this.el.append(el);\n        el.mousedown(e => {\n          this.mousedown = true;\n          this.currentHandle = i;\n        });\n      });\n    }\n\n    this.handleSliderMousemove = this.handleSliderMousemove.bind(this);\n    $(window).mousemove(this.handleSliderMousemove);\n    $(window).mouseup(() => {\n      this.mousedown = false;\n    });\n  }\n\n  setChunkDistance(value) {\n    this.chunkDistance = value;\n    this.chunkHandle.css('width', `${value}%`);\n  }\n\n  handleSliderMousemove(e) {\n    if (this.mousedown) {\n      if (this.isSectionSlider) {\n        let x = (e.pageX - this.el[0].getBoundingClientRect().left) / this.el[0].getBoundingClientRect().width * 100;\n        x = x + this.chunkDistance > 100 ? 100 - this.chunkDistance : x < 0 ? 0 : x;\n        this.chunkHandle.css('left', `${x}%`);\n        this.computeChunkHandlePos();\n      } else {\n        let x = (e.pageX - this.el[0].getBoundingClientRect().left) / this.el[0].getBoundingClientRect().width * 100;\n        x = x > 100 ? 100 : x < 0 ? 0 : x;\n        this.handles[this.currentHandle].css('left', `${x}%`);\n        this.computePos(this.currentHandle);\n      }\n\n      const event = $.Event('chart-scale-change');\n      event.pos = {\n        start: Math.min(...this.pos),\n        end: Math.max(...this.pos)\n      };\n      $(this).trigger(event);\n    }\n  }\n\n  computeChunkHandlePos() {\n    const h = this.chunkHandle[0].getBoundingClientRect();\n    const el = this.el[0].getBoundingClientRect();\n    this.pos[0] = (h.left - el.left) / el.width;\n    this.pos[0] = this.pos[0] < 0 ? 0 : this.pos[0];\n    this.pos[1] = this.pos[0] + this.chunkDistance / 100;\n  }\n\n  setHandle({\n    i,\n    position\n  }) {\n    this.handles[i].css('left', `${position}%`);\n    this.computePos(i);\n    const event = $.Event('chart-scale-change');\n    event.pos = {\n      start: Math.min(...this.pos),\n      end: Math.max(...this.pos)\n    };\n    $(this).trigger(event);\n  }\n\n  setChunkHandle(pos) {\n    this.chunkHandle.css('left', `${pos}%`);\n    this.computeChunkHandlePos();\n    const event = $.Event('chart-scale-change');\n    event.pos = {\n      start: Math.min(...this.pos),\n      end: Math.max(...this.pos)\n    };\n    $(this).trigger(event);\n  }\n\n  setHandleWithoutTrigger({\n    i,\n    pos\n  }) {\n    this.handles[i].css('left', `${pos}%`);\n    this.computePos(i);\n  }\n\n  computePos(i) {\n    const h = this.handles[i][0].getBoundingClientRect();\n    const el = this.el[0].getBoundingClientRect();\n    this.pos[i] = (h.left + h.width / 2 - el.left) / el.width;\n    this.pos[i] = this.pos[i] < 0 ? 0 : this.pos[i];\n  }\n\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./src/components/slider/slider.js?");

/***/ }),

/***/ "./src/mvc/controller.js":
/*!*******************************!*\
  !*** ./src/mvc/controller.js ***!
  \*******************************/
/*! exports provided: Controller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Controller\", function() { return Controller; });\n/* harmony import */ var _view2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view2 */ \"./src/mvc/view2.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./src/mvc/model.js\");\n\n\nclass Controller {\n  constructor(data) {\n    this.view = new _view2__WEBPACK_IMPORTED_MODULE_0__[\"View\"](data);\n    this.model = new _model__WEBPACK_IMPORTED_MODULE_1__[\"Model\"](data);\n    this.data = data;\n    this.handleWindowMousemove = this.handleWindowMousemove.bind(this);\n    this.handleWindowResize = this.handleWindowResize.bind(this);\n    $(this.view.canvas).click(() => {});\n    $(this.view.canvas).on('mousemove', this.handleWindowMousemove);\n    $(window).resize(this.handleWindowResize);\n  }\n\n  handleWindowMousemove(e) {\n    const x = e.clientX;\n    const y = e.clientY;\n\n    if (this.view.pointRadius > 1) {\n      this.view.pointIntersection({\n        x,\n        y,\n        e\n      });\n    }\n  }\n\n  handleWindowResize() {\n    this.view.timeOuts.forEach(el => {\n      clearTimeout(el);\n    });\n    this.data.diapason.full ? this.view.asyncReRender() : this.view.reRender();\n  }\n\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./src/mvc/controller.js?");

/***/ }),

/***/ "./src/mvc/model.js":
/*!**************************!*\
  !*** ./src/mvc/model.js ***!
  \**************************/
/*! exports provided: Model */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Model\", function() { return Model; });\nclass Model {\n  constructor(data) {\n    this.data = data;\n  }\n\n  scaleFromTo({\n    start,\n    end\n  }) {\n    const startIndex = Math.round(this.data.x.categories.length * start);\n    const endIndex = Math.round(this.data.x.categories.length * end);\n    return {\n      startIndex,\n      endIndex\n    };\n  }\n\n}\n\n//# sourceURL=webpack:///./src/mvc/model.js?");

/***/ }),

/***/ "./src/mvc/view2.js":
/*!**************************!*\
  !*** ./src/mvc/view2.js ***!
  \**************************/
/*! exports provided: View */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var _components_slider_slider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/slider/slider */ \"./src/components/slider/slider.js\");\n/* harmony import */ var _components_chartname_chartname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/chartname/chartname */ \"./src/components/chartname/chartname.js\");\n\n\nclass View {\n  constructor(data) {\n    this.timeOuts = [];\n    this.chunkSections = 10;\n    this.data = data;\n    this.promises = [];\n    this.font;\n    this.min;\n    this.max;\n    this.diapason;\n    this.sectionStartIndex;\n    this.sectionEndIndex;\n    this.sectionChunkStartIndex;\n    this.sectionChunkEndIndex;\n    this.startIndex;\n    this.endIndex;\n    this.chunks = 100;\n    this.dataArrays = this.data.series.map(el => el.data); // this.maxDataArrayLength = this.data.series.length > 1 ? this.dataArrays.reduce((a, el) => Math.max(a.length, el.length)) : this.data.series[0].data.length;\n\n    this.maxDataArrayLength = this.data.series[0].data.length;\n    this.sectionDiapason = this.maxDataArrayLength < 10000 ? this.maxDataArrayLength : this.maxDataArrayLength > 1000000 ? 50000 : 10000;\n    this.colors = new Set();\n    this.dataCoords = new Array(this.data.series.length).fill(0).map(() => []);\n    this.sectionSlider = new _components_slider_slider__WEBPACK_IMPORTED_MODULE_0__[\"Slider\"](true);\n    this.chunkSlider = new _components_slider_slider__WEBPACK_IMPORTED_MODULE_0__[\"Slider\"](false);\n    this.canvas = $('<canvas>');\n    this.$tip = $('<div>', {\n      class: 'tip'\n    });\n    this.nameY = $('<div>', {\n      class: 'nameY'\n    });\n    this.nameX = $('<div>', {\n      class: 'nameX'\n    });\n    this.canvasWrapper = $('<div>', {\n      class: 'canvasWrapper'\n    });\n    this.chartnames = $('<div>', {\n      class: 'chartnames'\n    });\n    this.context = this.canvas[0].getContext('2d');\n    this.mainWrapper = $('<div>', {\n      class: 'mainWrapper'\n    });\n    this.chartnamesArray;\n    this.canvasWidth;\n    this.canvasHeight;\n    this.Xstart;\n    this.Xend;\n    this.Xwidth;\n    this.Ystart;\n    this.Yend;\n    this.Yheight;\n    this.axisesCoordinates;\n    this.pointRadius = 2;\n    !this.data.diapason.full ? this.init() : this.asyncInit();\n  }\n\n  init() {\n    this.generateColor();\n    this.elementsInit();\n    this.defineSizes(this.canvasWrapper[0].getBoundingClientRect());\n    this.canvasResize();\n    this.minmaxData();\n    this.renderAxises(this.axisesCoordinates);\n    $(this.chunkSlider).on('chart-scale-change', e => {\n      const statrtEndIndexes = this.getIndexesDiapason({\n        pos: e.pos,\n        diapason: this.sectionEndIndex - this.sectionStartIndex\n      });\n      this.sectionChunkStartIndex = statrtEndIndexes.startIndex;\n      this.sectionChunkEndIndex = statrtEndIndexes.endIndex;\n      this.startIndex = this.sectionChunkStartIndex + this.sectionStartIndex;\n      this.endIndex = this.sectionChunkEndIndex + this.sectionStartIndex;\n      this.renderAllCharts({\n        startIndex: this.startIndex,\n        endIndex: this.endIndex\n      });\n    });\n    $(this.sectionSlider).on('chart-scale-change', e => {\n      const statrtEndIndexes = this.getIndexesDiapason({\n        pos: e.pos,\n        diapason: this.maxDataArrayLength\n      });\n      this.sectionStartIndex = statrtEndIndexes.startIndex;\n      this.sectionEndIndex = statrtEndIndexes.endIndex;\n      this.startIndex = this.sectionChunkStartIndex + this.sectionStartIndex;\n      this.endIndex = this.sectionChunkEndIndex + this.sectionStartIndex;\n      this.renderAllCharts({\n        startIndex: this.startIndex,\n        endIndex: this.endIndex\n      });\n    });\n    this.sectionSlider.setChunkHandle(0);\n    this.chunkSlider.setHandle({\n      i: 0,\n      position: 0\n    });\n    this.chunkSlider.setHandle({\n      i: 1,\n      position: 5\n    });\n  }\n\n  reRender() {\n    this.defineSizes(this.canvasWrapper[0].getBoundingClientRect());\n    this.canvasResize();\n    this.renderAxises(this.axisesCoordinates);\n    this.renderAllCharts({\n      startIndex: this.startIndex,\n      endIndex: this.endIndex\n    });\n  }\n\n  asyncReRender() {\n    this.data.$root.html('');\n    this.canvas = $('<canvas>');\n    this.$tip = $('<div>', {\n      class: 'tip'\n    });\n    this.nameY = $('<div>', {\n      class: 'nameY'\n    });\n    this.nameX = $('<div>', {\n      class: 'nameX'\n    });\n    this.canvasWrapper = $('<div>', {\n      class: 'canvasWrapper'\n    });\n    this.chartnames = $('<div>', {\n      class: 'chartnames'\n    });\n    this.context = this.canvas[0].getContext('2d');\n    this.mainWrapper = $('<div>', {\n      class: 'mainWrapper'\n    });\n    this.asyncInit();\n  }\n\n  asyncInit() {\n    this.generateColor();\n    this.elementsInit();\n    this.defineSizes(this.canvasWrapper[0].getBoundingClientRect());\n    this.canvasResize();\n    this.minmaxData();\n    this.renderAxises(this.axisesCoordinates);\n    this.startIndex = 0;\n    this.endIndex = this.maxDataArrayLength;\n    this.renderAllCharts({\n      startIndex: this.startIndex,\n      endIndex: this.endIndex\n    });\n  }\n\n  mainWrapperAppending() {\n    this.mainWrapper.append(this.canvasWrapper);\n    !this.data.diapason.full ? this.mainWrapper.append(this.sectionSlider.el) : 0;\n    !this.data.diapason.full ? this.mainWrapper.append(this.chunkSlider.el) : 0;\n    this.mainWrapper.append(this.chartnames);\n  }\n\n  elementsInit() {\n    this.nameY.append(this.data.y.title);\n    this.data.$root.append(this.nameY);\n    this.nameX.append(this.data.x.title);\n    this.canvasWrapper.append(this.canvas).append(this.nameX);\n    this.mainWrapperAppending();\n    this.canvasWrapper.append(this.$tip);\n    this.chunkSlider.el.css('margin-top', '5px');\n    this.data.$root.append(this.mainWrapper);\n    this.chartnamesArray = new Array(this.data.series.length).fill(0).map((el, i) => {\n      const color = this.colors[i];\n      const {\n        name\n      } = this.data.series[i];\n      const chartname = new _components_chartname_chartname__WEBPACK_IMPORTED_MODULE_1__[\"Chartname\"]({\n        color,\n        name\n      });\n      this.chartnames.append(chartname.container);\n      return chartname;\n    });\n  }\n\n  defineSizes(wrapperBoundingRect) {\n    this.canvasWidth = wrapperBoundingRect.width;\n    this.canvasHeight = wrapperBoundingRect.height;\n    this.Xstart = {\n      x: this.canvasWidth * 0.15,\n      y: this.canvasHeight * 0.85\n    };\n    this.Xend = {\n      x: this.canvasWidth * 0.9,\n      y: this.canvasHeight * 0.85\n    };\n    this.Xwidth = this.Xend.x - this.Xstart.x;\n    this.Ystart = {\n      x: this.canvasWidth * 0.1,\n      y: this.canvasHeight * 0.05\n    };\n    this.Yend = {\n      x: this.canvasWidth * 0.1,\n      y: this.canvasHeight * 0.75\n    };\n    this.Yheight = this.Yend.y - this.Ystart.y;\n    this.axisesCoordinates = {\n      Xaxis: {\n        start: this.Xstart,\n        end: this.Xend\n      },\n      Yaxis: {\n        start: this.Ystart,\n        end: this.Yend\n      }\n    };\n    const val = Math.round(this.sectionDiapason / this.maxDataArrayLength * 100);\n    this.sectionSlider.setChunkDistance(val);\n    this.font = this.canvasHeight * 0.01 > 3 ? `${3}px` : `${this.canvasHeight * 0.01}px`;\n  }\n\n  getIndexesDiapason({\n    pos,\n    diapason\n  }) {\n    return {\n      startIndex: Math.round(pos.start * diapason),\n      endIndex: Math.round(pos.end * diapason)\n    };\n  }\n\n  renderAxises({\n    Xaxis,\n    Yaxis\n  }) {\n    this.renderYaxis(Yaxis);\n    this.renderXaxis(Xaxis);\n  }\n\n  renderYaxis(axis) {\n    this.context.beginPath();\n    this.context.moveTo(axis.start.x, axis.start.y);\n    this.context.lineTo(axis.end.x, axis.end.y);\n    this.context.stroke();\n    this.addDelimitersY();\n  }\n\n  renderXaxis(axis) {\n    this.context.beginPath();\n    this.context.moveTo(axis.start.x, axis.start.y);\n    this.context.lineTo(axis.end.x, axis.end.y);\n    this.context.stroke();\n  }\n\n  canvasResize() {\n    this.canvas[0].width = this.canvasWidth;\n    this.canvas[0].height = this.canvasHeight;\n  }\n\n  minmaxData() {\n    let arr = [];\n    this.dataArrays.forEach((el, i) => {\n      arr = [...arr, ...el];\n    });\n    this.max = arr.reduce((a, b) => Math.max(a, b));\n    this.min = arr.reduce((a, b) => Math.min(a, b));\n    this.diapason = this.max - this.min;\n  }\n\n  pointIntersection({\n    x,\n    y,\n    e\n  }) {\n    const br = this.canvas[0].getBoundingClientRect();\n    let isIntersected = false;\n\n    for (let index = 0; index < this.dataCoords.length; index++) {\n      for (let i = 0; i < this.dataCoords[index].length; i++) {\n        const xx = this.dataCoords[index][i].x + br.x;\n        const yy = this.dataCoords[index][i].y + br.y;\n        const radius = Math.sqrt((xx - x) ** 2 + (yy - y) ** 2);\n\n        if (radius < this.pointRadius + 1) {\n          this.$tip.text(this.dataCoords[index][i].val);\n          isIntersected = true;\n          this.$tip.css('left', `${e.clientX}px`);\n          this.$tip.css('top', `${e.clientY}px`);\n          break;\n        }\n      }\n\n      if (isIntersected) {\n        break;\n      } else {\n        this.$tip.text('');\n      }\n    }\n  }\n\n  drawPoint({\n    data,\n    index,\n    i,\n    offset,\n    j\n  }) {\n    const y = this.Yend.y - (data[i] - this.min) / this.diapason * this.Yheight;\n    const x = this.Xstart.x + offset * j;\n\n    if (j > 0) {\n      const prevY = this.Yend.y - (data[i - 1] - this.min) / this.diapason * this.Yheight;\n      const prevX = this.Xstart.x + offset * (j - 1);\n      this.context.beginPath();\n      this.context.moveTo(x, y);\n      this.context.lineTo(prevX, prevY);\n      this.context.strokeStyle = this.colors[index];\n      this.context.stroke();\n      this.context.closePath();\n    }\n\n    if (this.pointRadius > 1.5) {\n      this.context.beginPath();\n      this.context.arc(x, y, this.pointRadius, 0, 2 * Math.PI);\n      this.dataCoords[index].push({\n        x,\n        y,\n        val: data[i]\n      });\n      this.context.fillStyle = this.colors[index];\n      this.context.fill();\n    }\n  }\n\n  definePointRadius(lngt) {\n    this.pointRadius = this.canvasHeight / lngt;\n    this.pointRadius = this.pointRadius > 5 ? 5 : this.pointRadius;\n    this.pointRadius = this.pointRadius < 1 ? 1 : this.pointRadius;\n  }\n\n  renderChartAsync({\n    data,\n    index,\n    startIndex,\n    endIndex\n  }) {\n    const length = endIndex - startIndex;\n    const offset = this.Xwidth / (endIndex - startIndex);\n    const chunks = length > 10000 ? Math.ceil(length / 10000) : 1;\n    const $this = this;\n    const chunkLength = 10000;\n\n    for (let j = 0; j < chunks; j++) {\n      const promise = () => new Promise((res, rej) => {\n        for (let i = 0; i < chunkLength; i++) {\n          if (chunkLength * j + i < length) {\n            this.drawPoint({\n              data,\n              index,\n              i: chunkLength * j + i,\n              offset,\n              j: i + j * chunkLength\n            });\n          }\n        }\n\n        res();\n      });\n\n      this.promises.push(promise);\n    }\n\n    this.promises.reduce((acc, cur) => acc.then(cur), Promise.resolve()).catch(e => console.log(e));\n  }\n\n  renderChart({\n    data,\n    index,\n    startIndex,\n    endIndex\n  }) {\n    const offset = this.Xwidth / (endIndex - startIndex);\n    const arr = data.slice(startIndex, endIndex);\n\n    for (let i = startIndex; i < endIndex; i++) {\n      const j = i - startIndex;\n      this.drawPoint({\n        data,\n        index,\n        i,\n        offset,\n        j\n      });\n    }\n  }\n\n  renderAllCharts({\n    startIndex,\n    endIndex\n  }) {\n    this.dataCoords = new Array(this.data.series.length).fill(0).map(() => []);\n    this.definePointRadius(endIndex - startIndex);\n    this.clearChart();\n    this.dataArrays.forEach((data, index) => {\n      const drawChartParametres = {\n        data,\n        index,\n        startIndex,\n        endIndex\n      };\n      this.data.diapason.full ? this.renderChartAsync(drawChartParametres) : this.renderChart(drawChartParametres);\n    });\n    this.addDelimitersX({\n      startIndex,\n      endIndex\n    });\n  }\n\n  clearChart() {\n    this.context.clearRect(this.Xstart.x - 2 * this.pointRadius, 0, this.canvasWidth, this.Yheight + this.Ystart.y + 2 * this.pointRadius);\n  }\n\n  generateColor() {\n    while (this.colors.size < this.data.series.length) {\n      this.colors.add(`rgba(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},1)`);\n    }\n\n    this.colors = Array.from(this.colors);\n  }\n\n  addDelimitersY() {\n    const exponent = ['Т', 'М'];\n\n    for (let i = 0; i < 10; i++) {\n      let divider = 1000;\n      let order = 0;\n      let value = (this.min + i * this.diapason / 9).toFixed(2);\n\n      while (value / divider > 1) {\n        divider *= divider;\n        order++;\n      }\n\n      divider /= 1000;\n      value = exponent[order - 1] ? (value / 1000 ** order).toFixed(1) + exponent[order - 1] : value;\n      const offset = this.Ystart.y + this.Yheight - i * this.Yheight / 9;\n      this.context.beginPath();\n      this.context.moveTo(this.Ystart.x, offset);\n      this.context.lineTo(this.Ystart.x - 10, offset);\n      this.context.stroke();\n      this.context.font = this.font;\n      this.context.textAlign = 'center';\n      this.context.fillText(value, this.Ystart.x - 30, offset);\n    }\n  }\n\n  addDelimitersX({\n    startIndex,\n    endIndex\n  }) {\n    this.context.clearRect(this.Xstart.x - 10, this.Xstart.y + 1, this.canvasWidth, this.canvasHeight);\n    const offset = this.Xwidth / (endIndex - startIndex);\n    let offset2 = offset;\n    const condition = endIndex - startIndex > 1000 || startIndex > 1000;\n    const multiplicity2 = condition ? 2 : 1;\n    let multiplicity = 1 * multiplicity2;\n\n    while (offset2 < 20) {\n      offset2 += offset;\n      multiplicity += 1 * multiplicity2;\n    }\n\n    for (let i = startIndex; i < endIndex; i++) {\n      if ((i + 1 - startIndex) % multiplicity !== 0) {\n        continue;\n      }\n\n      this.context.beginPath();\n      this.context.moveTo(this.Xstart.x + offset * (i - startIndex), this.Xstart.y);\n      this.context.lineTo(this.Xstart.x + offset * (i - startIndex), this.Xstart.y + 10);\n      this.context.strokeStyle = '#000';\n      this.context.stroke();\n      this.context.font = this.font;\n      this.context.textAlign = 'center';\n      this.context.fillStyle = '#000';\n      this.context.fillText(this.data.x.categories[i], this.Xstart.x + offset * (i - startIndex), this.Xstart.y + 10 + 10);\n    }\n  }\n\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./src/mvc/view2.js?");

/***/ }),

/***/ "./src/plugin.js":
/*!***********************!*\
  !*** ./src/plugin.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(jQuery) {/* harmony import */ var _mvc_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mvc/controller */ \"./src/mvc/controller.js\");\n\n\n(function ($) {\n  const methods = {\n    coords() {\n      const $this = $(this);\n      const chart = $this.data('myChart');\n      return chart.chart.view.dataArrays;\n    },\n\n    init(options) {\n      return this.each(function () {\n        const $this = $(this);\n        const data = $this.data('myChart');\n        const chart = new _mvc_controller__WEBPACK_IMPORTED_MODULE_0__[\"Controller\"]({ ...options,\n          $root: $this\n        });\n\n        if (!data) {\n          $(this).data('myChart', {\n            target: $this,\n            chart\n          });\n        }\n      });\n    }\n\n  };\n\n  $.fn.myChart = function (method) {\n    if (methods[method]) {\n      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n\n    if (typeof method === 'object' || !method) {\n      return methods.init.apply(this, arguments);\n    }\n\n    $.error(`Метод с именем ${method} не существует для jQuery.myChart`);\n  };\n})(jQuery);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./src/plugin.js?");

/***/ })

}]);